// Generated by CoffeeScript 1.3.3
(function() {
  var API, CoinsE, Cryptsy, Vircurex, calculateAverage, coinsE, cryptsy, http, https, markets, vircurex,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Array.prototype.remove = function(e) {
    var t, _ref;
    if ((t = this.indexOf(e)) > -1) {
      return ([].splice.apply(this, [t, t - t + 1].concat(_ref = [])), _ref);
    }
  };

  http = require('http');

  https = require('https');

  http.createServer(function(request, response) {
    response.writeHead(200, {
      'Content-Type': 'application/json'
    });
    response.write(JSON.stringify(calculateAverage()));
    return response.end();
  }).listen(process.env.PORT || 5000);

  console.log('Server Started');

  markets = {
    cryptsy: {},
    coins_e: {},
    vircurex: {},
    average: {}
  };

  API = (function() {

    function API() {}

    API.prototype.onData = function(chunk) {
      return this.content += chunk.toString();
    };

    API.prototype.onEnd = function() {};

    API.prototype.onError = function(error) {
      return console.log("Error while calling endpoint.", error);
    };

    API.prototype.process = function() {
      var request, that;
      this.content = "";
      that = this;
      request = this.protocol.request(this.options(), function(response) {
        response.on('data', function(chunk) {
          return that.onData(chunk);
        });
        return response.on('end', function() {
          return that.onEnd();
        });
      });
      request.on('error', function(error) {
        return that.onError(error);
      });
      return request.end();
    };

    return API;

  })();

  CoinsE = (function(_super) {

    __extends(CoinsE, _super);

    function CoinsE(market, protocol) {
      this.market = market;
      this.protocol = protocol != null ? protocol : https;
    }

    CoinsE.prototype.options = function() {
      return {
        host: 'www.coins-e.com',
        path: "/api/v2/market/" + this.market + "/depth/",
        method: 'GET',
        port: 443
      };
    };

    CoinsE.prototype.onEnd = function() {
      try {
        this.data = JSON.parse(this.content);
        markets.coins_e = {
          price: this.data.ltp * 1
        };
      } catch (error) {
        markets.coins_e = {
          price: void 0
        };
        console.log(error);
      }
      return this.content = "";
    };

    return CoinsE;

  })(API);

  Cryptsy = (function(_super) {

    __extends(Cryptsy, _super);

    function Cryptsy(market, protocol) {
      this.market = market;
      this.protocol = protocol != null ? protocol : http;
    }

    Cryptsy.prototype.options = function() {
      return {
        host: 'pubapi.cryptsy.com',
        path: "/api.php?method=singlemarketdata&marketid=" + this.market,
        method: 'GET'
      };
    };

    Cryptsy.prototype.onEnd = function() {
      var doge;
      try {
        this.data = JSON.parse(this.content);
        doge = this.data["return"].markets.DOGE;
        markets.cryptsy = {
          price: doge.lasttradeprice * 1
        };
      } catch (error) {
        markets.cryptsy = {
          price: void 0
        };
        console.log(error);
      }
      return this.content = "";
    };

    return Cryptsy;

  })(API);

  Vircurex = (function(_super) {

    __extends(Vircurex, _super);

    function Vircurex(market, protocol) {
      this.market = market;
      this.protocol = protocol != null ? protocol : https;
    }

    Vircurex.prototype.options = function() {
      return {
        host: 'api.vircurex.com',
        path: "/api/get_last_trade.json?base=" + this.market + "&alt=BTC",
        method: 'GET',
        port: 443
      };
    };

    Vircurex.prototype.onEnd = function() {
      try {
        this.data = JSON.parse(this.content);
        markets.vircurex = {
          price: this.data.value * 1
        };
      } catch (error) {
        markets.vircurex = {
          price: void 0
        };
        console.log(error);
      }
      return this.content = "";
    };

    return Vircurex;

  })(API);

  calculateAverage = function() {
    var average, price, prices, _i, _len;
    prices = [markets.vircurex.price, markets.coins_e.price, markets.cryptsy.price];
    prices.remove(void 0);
    average = 0;
    for (_i = 0, _len = prices.length; _i < _len; _i++) {
      price = prices[_i];
      average += price;
    }
    markets.average = {
      price: (average / prices.length).toFixed(8) * 1
    };
    return markets;
  };

  cryptsy = new Cryptsy(132);

  coinsE = new CoinsE("DOGE_BTC");

  vircurex = new Vircurex("DOGE");

  cryptsy.process();

  coinsE.process();

  vircurex.process();

  setInterval(function() {
    cryptsy.process();
    coinsE.process();
    return vircurex.process();
  }, 60 * 1000);

}).call(this);
